<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Perspective Twist Text</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>
body {
  background: #fafafa;
  font-family: system-ui, sans-serif;
  padding: 16px;
}

.controls {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  align-items: center;
  margin-bottom: 12px;
}

input[type="text"] {
  font-size: 16px;
  padding: 6px 8px;
  width: 260px;
}

svg {
  width: 100%;
  max-width: 1100px;
  height: 420px;
  border: 1px solid #ccc;
  background: white;
}

.small {
  font-size: 13px;
  color: #666;
  margin-bottom: 6px;
}
</style>
</head>
<body>

<h3>Perspective Twist Text Generator</h3>

<div class="controls">
  <input id="textInput" type="text" value="BLOCK">

  <label>Z Rotate
    <input id="rotateZ" type="range" min="0" max="1080" value="0">
  </label>

  <label>Samples
    <input id="samples" type="number" min="3" max="80" value="16" style="width:70px">
  </label>

  <label>Vanishing X
    <input id="vX" type="number" value="550" style="width:80px">
  </label>

  <label>Vanishing Y
    <input id="vY" type="number" value="40" style="width:80px">
  </label>

  <label>Upload TTF/OTF
    <input id="fontUpload" type="file" accept=".ttf,.otf">
  </label>

  <button id="renderBtn">Render</button>
</div>

<div class="small">
Upload a font, click Render. Only the text rotates. The vanishing point stays locked.
</div>

<svg id="svg" viewBox="0 0 1100 420"></svg>

<script src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>

<script>
const svg = document.getElementById("svg");
const textInput = document.getElementById("textInput");
const rotateZ = document.getElementById("rotateZ");
const samplesInput = document.getElementById("samples");
const vXInput = document.getElementById("vX");
const vYInput = document.getElementById("vY");
const fontUpload = document.getElementById("fontUpload");
const renderBtn = document.getElementById("renderBtn");

let loadedFont = null;

// math helpers
function cubic(p0,p1,p2,p3,t){
  const u=1-t;
  return {
    x:u*u*u*p0.x+3*u*u*t*p1.x+3*u*t*t*p2.x+t*t*t*p3.x,
    y:u*u*u*p0.y+3*u*u*t*p1.y+3*u*t*t*p2.y+t*t*t*p3.y
  };
}

function quad(p0,p1,p2,t){
  const u=1-t;
  return {
    x:u*u*p0.x+2*u*t*p1.x+t*t*p2.x,
    y:u*u*p0.y+2*u*t*p1.y+t*t*p2.y
  };
}

function samplePath(path, samples){
  let pts=[];
  let cur={x:0,y:0};
  path.commands.forEach(cmd=>{
    if(cmd.type==="M"){cur={x:cmd.x,y:cmd.y};pts.push(cur);}
    else if(cmd.type==="L"){
      const a=cur,b={x:cmd.x,y:cmd.y};
      for(let i=0;i<=1;i++)
        pts.push({x:a.x+(b.x-a.x)*i,y:a.y+(b.y-a.y)*i});
      cur=b;
    }
    else if(cmd.type==="C"){
      const p0=cur,p1={x:cmd.x1,y:cmd.y1},
            p2={x:cmd.x2,y:cmd.y2},p3={x:cmd.x,y:cmd.y};
      for(let i=0;i<=samples;i++) pts.push(cubic(p0,p1,p2,p3,i/samples));
      cur=p3;
    }
    else if(cmd.type==="Q"){
      const p0=cur,p1={x:cmd.x1,y:cmd.y1},p2={x:cmd.x,y:cmd.y};
      for(let i=0;i<=samples;i++) pts.push(quad(p0,p1,p2,i/samples));
      cur=p2;
    }
  });
  return pts;
}

fontUpload.addEventListener("change", async e=>{
  const f=e.target.files[0];
  if(!f) return;
  const buf=await f.arrayBuffer();
  loadedFont=opentype.parse(buf);
});

renderBtn.addEventListener("click", ()=>{
  if(!loadedFont) return alert("Upload a font first.");

  const text=textInput.value||"BLOCK";
  const samples=parseInt(samplesInput.value);
  const vX=Number(vXInput.value);
  const vY=Number(vYInput.value);

  while(svg.firstChild) svg.removeChild(svg.firstChild);

  const fixedGroup=document.createElementNS("http://www.w3.org/2000/svg","g");
  const glyphGroup=document.createElementNS("http://www.w3.org/2000/svg","g");
  glyphGroup.id="glyphGroup";

  svg.appendChild(fixedGroup);
  svg.appendChild(glyphGroup);

  const fontSize=160;
  const startX=80;
  const baseY=240;

  // draw glyphs
  const fullPath=loadedFont.getPath(text,startX,baseY,fontSize);
  const glyphPath=document.createElementNS("http://www.w3.org/2000/svg","path");
  glyphPath.setAttribute("d",fullPath.toPathData());
  glyphPath.setAttribute("fill","#000");
  glyphGroup.appendChild(glyphPath);

  // sample per glyph
  let penX=startX;
  let allPts=[];
  const glyphs=loadedFont.stringToGlyphs(text);

  for(let i=0;i<glyphs.length;i++){
    const g=glyphs[i];
    const p=g.getPath(penX,baseY,fontSize);
    allPts.push(...samplePath(p,samples));
    const kern=i<glyphs.length-1?loadedFont.getKerningValue(g,glyphs[i+1]):0;
    penX+=g.advanceWidth*(fontSize/loadedFont.unitsPerEm)+kern*(fontSize/loadedFont.unitsPerEm);
  }

  allPts.forEach(pt=>{
    const l=document.createElementNS("http://www.w3.org/2000/svg","line");
    l.setAttribute("x1",pt.x);
    l.setAttribute("y1",pt.y);
    l.setAttribute("x2",vX);
    l.setAttribute("y2",vY);
    l.setAttribute("stroke","#111");
    l.setAttribute("stroke-width","0.8");
    fixedGroup.appendChild(l);
  });

  const vp=document.createElementNS("http://www.w3.org/2000/svg","circle");
  vp.setAttribute("cx",vX);
  vp.setAttribute("cy",vY);
  vp.setAttribute("r","3.5");
  vp.setAttribute("fill","#111");
  fixedGroup.appendChild(vp);
});

rotateZ.addEventListener("input", ()=>{
  const g=document.getElementById("glyphGroup");
  if(!g) return;
  const cx=550, cy=210;
  g.setAttribute("transform",`rotate(${rotateZ.value} ${cx} ${cy})`);
});
</script>
</body>
</html>
