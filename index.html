<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Perspective Twist Text (Animated)</title>

<style>
body {
  font-family: system-ui, sans-serif;
  background: #fafafa;
  padding: 16px;
}

.controls {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  align-items: center;
  margin-bottom: 12px;
}

svg {
  width: 100%;
  max-width: 1100px;
  height: 420px;
  border: 1px solid #ccc;
  background: white;
}

.small { font-size: 13px; color: #666; }
</style>
</head>
<body>

<h3>Perspective Twist Text (Animated)</h3>

<div class="controls">
  <input id="textInput" type="text" value="BLOCK">

  <label>Z Rotate
    <input id="rotateZ" type="range" min="0" max="1080" value="0">
  </label>

  <label>Samples
    <input id="samples" type="number" min="3" max="80" value="16" style="width:70px">
  </label>

  <label>Vanishing X <input id="vX" type="number" value="550" style="width:80px"></label>
  <label>Vanishing Y <input id="vY" type="number" value="40" style="width:80px"></label>

  <label>Upload TTF/OTF
    <input id="fontUpload" type="file" accept=".ttf,.otf">
  </label>

  <button id="renderBtn">Render</button>
</div>

<div class="small">
Rotation is applied in geometry space. Lines stay connected. Drag the slider to twist dynamically.
</div>

<svg id="svg" viewBox="0 0 1100 420"></svg>

<script src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>
<script>
const svg = document.getElementById("svg");
const textInput = document.getElementById("textInput");
const rotateZ = document.getElementById("rotateZ");
const samplesInput = document.getElementById("samples");
const vXInput = document.getElementById("vX");
const vYInput = document.getElementById("vY");
const fontUpload = document.getElementById("fontUpload");
const renderBtn = document.getElementById("renderBtn");

let font = null;
let rotationDeg = 0;

// math helpers
const rad = d => d * Math.PI / 180;

function rotatePoint(p, cx, cy, a) {
  const r = rad(a);
  const cos = Math.cos(r), sin = Math.sin(r);
  const x = p.x - cx;
  const y = p.y - cy;
  return {
    x: cx + x * cos - y * sin,
    y: cy + x * sin + y * cos
  };
}

function cubic(p0,p1,p2,p3,t){
  const u=1-t;
  return {
    x:u*u*u*p0.x+3*u*u*t*p1.x+3*u*t*t*p2.x+t*t*t*p3.x,
    y:u*u*u*p0.y+3*u*u*t*p1.y+3*u*t*t*p2.y+t*t*t*p3.y
  };
}

function quad(p0,p1,p2,t){
  const u=1-t;
  return {
    x:u*u*p0.x+2*u*t*p1.x+t*t*p2.x,
    y:u*u*p0.y+2*u*t*p1.y+t*t*p2.y
  };
}

function samplePath(path, samples){
  let pts=[], cur={x:0,y:0};
  path.commands.forEach(c=>{
    if(c.type==="M"){cur={x:c.x,y:c.y}; pts.push(cur);}
    else if(c.type==="L"){ cur={x:c.x,y:c.y}; pts.push(cur);}
    else if(c.type==="C"){
      const p0=cur,p1={x:c.x1,y:c.y1},p2={x:c.x2,y:c.y2},p3={x:c.x,y:c.y};
      for(let i=0;i<=samples;i++) pts.push(cubic(p0,p1,p2,p3,i/samples));
      cur=p3;
    }
    else if(c.type==="Q"){
      const p0=cur,p1={x:c.x1,y:c.y1},p2={x:c.x,y:c.y};
      for(let i=0;i<=samples;i++) pts.push(quad(p0,p1,p2,i/samples));
      cur=p2;
    }
  });
  return pts;
}

let allPts = [];

function renderStatic() {
  if (!font) return;

  while(svg.firstChild) svg.removeChild(svg.firstChild);

  const fixed = document.createElementNS("http://www.w3.org/2000/svg","g");
  svg.appendChild(fixed);

  const fontSize = 160;
  const startX = 80;
  const baseY = 240;

  const path = font.getPath(textInput.value || "BLOCK", startX, baseY, fontSize);
  const bbox = path.getBoundingBox();
  const cx = (bbox.x1 + bbox.x2)/2;
  const cy = (bbox.y1 + bbox.y2)/2;

  // sample all points
  let penX = startX;
  allPts = [];
  font.stringToGlyphs(textInput.value || "BLOCK").forEach((g,i,a)=>{
    const p = g.getPath(penX, baseY, fontSize);
    const pts = samplePath(p, +samplesInput.value).map(pt => ({x:pt.x, y:pt.y}));
    allPts.push(...pts);
    const k = i<a.length-1?font.getKerningValue(g,a[i+1]):0;
    penX += g.advanceWidth*(fontSize/font.unitsPerEm) + k*(fontSize/font.unitsPerEm);
  });

  // draw glyph path
  const glyphPathEl = document.createElementNS("http://www.w3.org/2000/svg","path");
  glyphPathEl.setAttribute("d", path.toPathData());
  glyphPathEl.setAttribute("fill","#000");
  svg.appendChild(glyphPathEl);

  return {cx, cy, fixed};
}

let currentCx, currentCy, fixedGroup;

function render() {
  if(!allPts.length) return;
  const vX = +vXInput.value;
  const vY = +vYInput.value;

  while(fixedGroup.firstChild) fixedGroup.removeChild(fixedGroup.firstChild);

  allPts.forEach(pt=>{
    const rp = rotatePoint(pt, currentCx, currentCy, rotationDeg);
    const line = document.createElementNS("http://www.w3.org/2000/svg","line");
    line.setAttribute("x1", rp.x);
    line.setAttribute("y1", rp.y);
    line.setAttribute("x2", vX);
    line.setAttribute("y2", vY);
    line.setAttribute("stroke","#111");
    line.setAttribute("stroke-width","0.8");
    fixedGroup.appendChild(line);
  });

  // vanishing point
  const vp = document.createElementNS("http://www.w3.org/2000/svg","circle");
  vp.setAttribute("cx",vX);
  vp.setAttribute("cy",vY);
  vp.setAttribute("r","3.5");
  vp.setAttribute("fill","#111");
  fixedGroup.appendChild(vp);
}

// font upload
fontUpload.addEventListener("change", async e=>{
  const f = e.target.files[0];
  if(!f) return;
  font = opentype.parse(await f.arrayBuffer());
  const {cx, cy, fixed} = renderStatic();
  currentCx = cx;
  currentCy = cy;
  fixedGroup = fixed;
  render();
});

// initial render button
renderBtn.addEventListener("click", ()=>{
  if(!font) return;
  const {cx, cy, fixed} = renderStatic();
  currentCx = cx;
  currentCy = cy;
  fixedGroup = fixed;
  render();
});

// dynamic rotation
rotateZ.addEventListener("input", ()=>{
  rotationDeg = +rotateZ.value;
  render();
});
</script>
</body>
</html>
